#面试
Java数组的三种打印方式
（1）传统的for循环方式
```java
for(int i=0;i<array.length;i++)
{
      System.out.println(array[i]);
}
```
（2）for each循环
```java

for(int a:array)
    System.out.println(a);
```
(3）利用Array类中的toString方法
```java

int[] array = {1,2,3,4,5};
System.out.println(Arrays.toString(array));
```
   推荐使用
请解释一下这行代码a [s1.charAt(i) - 'a'] ++;
```java
for (int i = 0; i < s1.length(); i++)
    a[s1.charAt(i) - 'a']++;
```
s1.charAt(i)返回s1 i的第th个字符String. 假设此String仅包含小写字母(即'a'到'z'),s1.charAt(i)-'a'将字符'a'映射到索引0,将'b'映射到索引1,依此类推('z'映射到索引25) .
```java
a[s1.charAt(i)-'a']++;
```
递增与该字符对应的计数器s1.charAt(i).

因此,此循环计算每个字母的出现次数String s1.

最后,a[0]将包含'a' a[1]的数量,'b'的数量等等.


总结：https://blog.csdn.net/springyh/article/details/80603285
list转set集合：只需要在set集合中传入list即可
set集合转化为list集合，和上面一样，只需要在list集合方法形参里面传入set集合
set集合转化为数据：toArray() 方法
list集合转化位数组：toAyyay()方法
数组转化为lit集合：Arrays.asList(数组)
数组转化为set集合：数组先转化位list集合，然后作为形参传入到set集合中
```java
public static void mian(String[] args){
    //数组转化为set集合思路
    //数组先转化为list集合,然后list转化为set集合
    String[] str = {"a","b","c","d" };
    List<String> asList = Arrays.aslist(str);
    Set<String> set = new HashSet<String>(asList);
    for(String string:set){
    system.out.print(string)；
}
}
```
##关于位运算
& 与 两个位都是1，结果才是1
| 或 两个位都是0，结果才位0
^ 异或 相同为0，不同为1
0&0=0  0&1=0  1&0=0  1&1=1
总结：两位同时为1，结果才为1，否则结果为0。
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。
####判断奇偶数字
(数字&1==0) 说明是0，是偶数
(数字&0==0) 说明是1，是奇数

##数组拷贝
java的arrayCopy用法
它可以实现将一个数组的指定个数元素复制到另一个数组中
直接举例:

arrayCopy( arr1, 2, arr2, 5, 10);

意思是;将arr1数组里从索引为2的元素开始, 复制到数组arr2里的索引为5的位置, 复制的元素个数为10个. 

举例:
```java

Int[] arr1 ={1,2,3,4,5};

arrayCopy(arr1, 3, arr1, 2, 2);

意思是:将arr1从数字4开始 拷贝到arr1的数字3的位置, 拷贝2个数, 也就是说将4和5 拷贝到数字3的位置,相当于删除数字3.
```
队列的add与offer的区别
两个方法都表示往队列里添加元素

但是当出现异常时，add方法抛出异常

而offer则返回的是false，就是啥事也没有，也不抛异常，也没有添加成功

Java队列的poll,peek,element的区别
poll,peek,element的共同点：
都是返回队列中的首个元素
不同点：
poll：将首个元素从队列中弹出，如果队列是空的，就返回null
peek：查看首个元素，不会移除首个元素，如果队列是空的就返回null
element：查看首个元素，不会移除首个元素，如果队列是空的就抛出异常NoSuchElementException
element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，
二者唯一的区别是当方法失败时前者抛出异常，后者返回null

java.util.LinkedList.pollLast()
offerLast(element)指定元素添加在列表的末尾，
pollLast()返回列表的最后一个元素并从列表中移除


Map中的map.keySet()方法 就是获取map的key的名称。
KeySet():
将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，
再根据get方法。获取每一个键对应的值。 
keySet():迭代后只能通过get()取key

用 for (String key : hashmap名字.keySet())读取map

//列表转二维数组
return list.toArray(new int[0][]);

###动态规划问题的一般形式就是求最值
###动态规划的核心设计思想是数学归纳法。
求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗
首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

####核心 状态转移方程
穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

####解决重叠子问题--备忘录
自己造一个备忘录，每次算出某个子问题的答案别着急返回，先记到【备忘录】里再返回
每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。
一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

动态规划一般都是【自底向上】
啥叫「自底向上」？反过来，我们直接从最底下，最简单，
问题规模最小的 f(1) 和 f(2) 开始往上推，
直到推到我们想要的答案 f(20)，这就是动态规划的思路，
这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

####究竟什么是状态转移方程呢？
实际就是描述问题结构的数学形式
f（n) = 1 ,n=1,2
f(n) = f(n-1)+f(n-2),n>2
很容易发现，其实状态转移方程直接代表着暴力解法。千万不要看不起暴力解，
动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言


要符合「最优子结构」，子问题间必须互相独立。
得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，
比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高
数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。


###动态规划系列
具体来说，动态规划的一般流程就是三步：暴力的递归解法 -> 带备忘录的递归解法 -> 迭代的动态规划解法。
就思考流程来说，就分为一下几步：找到状态和选择 -> 明确 dp 数组/函数的定义 -> 寻找状态之间的关系。

###明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。



###总结
求最小的元素=------使用大顶堆
求最大的元素-------使用小顶堆



